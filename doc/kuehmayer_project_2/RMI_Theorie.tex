\subsection{Theorie}

\subsubsection{RPC (Remote Procedure Call)}
\paragraph{Hintergrund} \mbox{} \vspace{2mm} \\ 
Ein Remote Procedure Call (RPC)\footnote{\cite{rpc-datacenter}} ist eine Methodik zum Ausführen von Prozeduren auf einem entfernten Rechner. Es wird meistens zur Realisierung von Client/Server-Architekturen verwendet und beruht auf dem UDP- oder TCP-Protokoll. Die ersten RPCS, wurden von Sun Microsystems für ein Network File System entwickelt. Schon im Jahre 1976 wurde die ersten Ansätze der Technik des remoten Aufrufens von Prozeduren von  James E. White in de RFC 707 niedergeschrieben. Diese Technik wurde in der Folge von weiteren Netzwerk Systemen wie Xerox Network Systems (XNS) oder Novells Netware eingesetzt. Im Jahre 1994 bekamen dann sogar die Herren Andrew Birrell und Bruce Nelson den ACM Software System Award für ihre Entwicklung. Durch den Gewinn dieses Preises, wurde sowohl die RPC-Variante Sun-RPC als auch die RPC-Variante ONC-RPC (Open Network Computing Remote Procedure Call) bekannt. Neben diesen beiden schaffte es auch die Variante Distributed Computing Environment Remote Procedure Call (DCE-RPC) bekannt zu werden und diese galt zum damaligen Zeitpunkt als verbreitetste Variante. Von dieser Variante leitet Microsoft ihre eigene Variante ab, den Microsoft-RPC (MSRPC). Die Grundidee hinter der Technik des RPC, galt der Speicherplatz Erweiterung. Man wollte über ein Netzwerk Speicherplätze zur Verfügung stellen, dieser sollte so zuverlässig wie der stationäre Speicherplatz sein. Für dieses Vorhaben wurde mithilfe von RPC eine Reihe von Befehlen erstellt, welche über ein Client-Server-Modell die Speicher-Routinen abarbeiten sollten.

\paragraph{Wie funktioniert RPC?} \mbox{} \vspace{2mm} \\
Die Kommunikation bei einem RPC verläuft nach dem folgenden Prinzip: Der Client sendet dem Server einen RPC. Dieser Server empfängt die RPC-Anfrage mittels eines installierten Portmappers (Endpointmapper). Die in dieser Anfrage enthaltenen Daten werden dann weiter an die jeweilige Server-Anwendung weiter gegebnen. Diese Server-Anwendung verarbeitet dann den Auftrag und sendet dem Client das Ergebnis, eine Fehlermeldung oder einen Status zurück.

\paragraph{Probleme} \mbox{} \vspace{2mm} \\
Jedoch können bei einem RPC Aufruf verschiedene Fehler in der Kommunikation entstehen. Diese Fehler müssen von Programmieren in der Entwicklung einer solchen Anwendung auf jeden Fall beachtet werden. Es könnt zum Beispiel passieren, dass der Server keine Antwort auf den RPC Aufruf eines Clients gibt. Doch nicht nur auf dem Client können Probleme auftreten, der Server sollte sich merken, welcher Client welche Funktion schon ausgeführt hat, um einen mehrfachen Aufruf dieser Funktion zu vermeiden. Jedoch gibt es bei der RPC Technik verschiedene Möglichkeiten, solche Probleme zu verhinder und dadurch die Datenintegrität zu gewährleisten. Jedoch muss man dafür erst mal zwischen der Technik des synchronem RPC und des asynchronen RPC unterscheiden. Ist die Kommunikation für synchrones RPC ausgelegt, muss der Server die Ausführung schnell durchführen, da ansonsten der Client blockiert wird, da er auf die Antwort vom Server wartet. Dieses Problem tritt bei der Technik des asynchronen RPCs nicht auf, da der Client, während er auf die Antwort wartet, weitere Operationen ausführen kann. Jedoch ist es schwieriger, asynchrone RPCs zu implementieren, da, wenn ein Fehler auftritt, dass Programm aber zwischenzeitlich schon weiter gearbeitet hat, dieser Fehler nicht behoben werden kann und dadurch das Programm beendet werden muss.


\subsubsection{RMI (Remote Method Invocation)}

\paragraph{Hintergrund} \mbox{} \vspace{2mm} \\ 
Remote Method Invocation \footnote{\cite{rmi}} bezeichnet das entfernte Aufrufen von Methoden und Zugriffsvariablen und ist eine spezifische Methode der Programmiersprache Java. Die Anfänge des RMI liegen in der Realisierung eines verteilten Objektmodells in Java, welches die Interaktion von Remote-Objekten erlauben sollte. Diese Interaktion mit den Remote-Objekten sollte möglichst nahe an der Interaktion mit lokalen Java-Objekten liegen. In diesem Kontext werden Remote-Objekte verstanden, welche sich entweder auf entfernten externen Rechner-Systemen befinden oder aber getrennt auf einer anderen Java Virtual Maschine (JVM) laufen. Für die Kommunikation gibt es verschiedene für eine bestimmten Zweck zugeschnittene Protokolle. Unter diesen Protokollen gitb es zum Beispiel das Java Remote Method Protocol (JRMP), welches auch unter dem Namen Wire-Protocol bekannt ist. Dieses Protokoll ist für die RMI das implementierte Standardprotokoll. Aber es gibt auch andere, für einen bestimmten Zweck angepasste Protokolle. So gibt es zum Beispiel das RMI IIOP Prtotkoll, welches zur Integration in der Common Object Request Broker Architecture (CORBA), welche weitere Mechanismen zur verteilten Anwendungsprogrammierung bereitstellt. Die Kommunikation der RMI kann über HTTP getunnelt werden und somit steht eine Möglichkeit bereit, eine Firewall zu umgehen. RMI ist durch die Verschlüsselung mit Secure Socket Layer (SSL) eine sichere Möglichkeit der Kommunikation.

\paragraph{Verwendung von RMI} \mbox{} \vspace{2mm} \\ 
Durch RMI wird das transparente Verschicken von Objekten und deren Funktionen sowie das dynamische Nachladen von Objektklassen unterstützt. Die Java-Standardumgebung beinhaltet alle notwendigen Methoden und Mechanismen der RMI-Klassenbibliothek. Dadurch ist die Verwendung von entfernten Objekten auf gleiche Weise wie lokale Objekte möglich und auch der Aufruf von Methoden der Objekte ist remote sehr ähnlich zu dem lokalen Aufruf. Durch einen höher entwickelten Mechanismus werden die Methoden der Remote-Objekte aufgerufen. Diesen Methoden kann man Objekte vollständig als Wert oder als Referenz übergeben. Kommunikationsfehler oder andere Fehler können durchaus vorkommen, weshalb es vordefinierte Error-Messages RMI-Klassenbibliothek gibt.

\paragraph{RMI-Ebenen} \mbox{} \vspace{2mm} \\ 
RMI integriert drei verschiedene Ebnen, welche abhängig von den spezifischen Anwendungen, ob es auf einem Externen oder demselben System in einer anderen JVM liegt, von jedem einzelnen Methodenaufruf durchlaufen. Diese drei Ebenen sind: die Transportebene, die Remote Reference Ebene und die 'Stubs'. Die Transportebene ist für die Behandlung der Netzwerkverbindung zwischen den verschiedenen Systemen zuständig. Während die Remote Reference Ebene für die Zusammenstellung des Methodenaufrufs für die Aufbereitung der Parameter und die Aufbereitung der späteren Rückgabewerte zuständig ist. Die Ebene der 'Stubs' ist die Ebene, auf welcher der Server und der Client agieren und auf beiden Seiten quasi Stellvertreter-Objekte, die die Daten von der eigentlichen Implementierungsklasse übernehmen, bereitstellen. Dadurch wird das Stub-Objekt auch der lokale Stellvertreter für das Remote-Objekt genannt.